Контрольные вопросы: лекция 11
1)	Что обеспечивает идеальная передача и как она реализуется?
Идеальная передача делает возможным программирование на более высоком уровне. Функции высшего порядка – это функции, которые могут принять другие функции в качестве аргументов или возвращать их. (под функциями понимаются классы, конструкторы )(Это важно, когда аргументов много)
Реализуется за счет универсальных ссылок и функции std::forward, которая из lvalue переводит в rvalue

2)	Какая ссылка называется пробрасывающей или универсальной?
Пробрасывающая ссылка называется T&&, если Т – тип из шаблона
•	Если выражение, которым инициализируется универсальная ссылка является lvalue, то универсальная ссылка становиться lvalue ссылкой.
•	Если выражение, которым инициализируется универсальная ссылка является rvalue, то универсальная ссылка становиться rvalue ссылкой.
Приведение к rvalue возможно благодаря std::forward

3)	В чем заключается идиома SFINAE применительно к шаблонам?
Идиома заключается в том, что игнорируется шаблон, если он не подходит (т.е проверка совместимости шаблона с принимаемым типом дает отрицательный результат)

4)	Как можно использовать вспомогательный шаблон enable_if?
Обычно enable_if используется для удаления кандидатов из разрешения перегрузки, т. е. функция отбраковывает набор перегрузки, чтобы одно определение было отброшено в пользу другого. Это соответствует поведению SFINAE.
4 примера сценариев (взяты с сайта microsoft)
1)	Сценарий 1. Упаковка возвращаемого типа функции:
template <your_stuff>
typename enable_if<your_condition, your_return_type>::type
    yourfunction(args) {// ...
}
    template <your_stuff>
enable_if_t<your_condition, your_return_type>
yourfunction(args) {// ...
}

2)	Сценарий 2. Добавление параметра функции с аргументом по умолчанию:
template <your_stuff>
your_return_type_if_present
    yourfunction(args, enable_if_t<your condition, FOO> = BAR) {// ...
}
3)	Сценарий 3. Добавление параметра шаблона с аргументом по умолчанию:
template <your_stuff, typename Dummy = enable_if_t<your_condition>>
rest_of_function_declaration_goes_here

4)	Сценарий 4. Если функция содержит аргумент без шаблона, ее тип можно упаковать:
template <typename T>
void your_function(const T& t,
    enable_if_t<is_something<T>::value, const string&>
s) {// ...
}






5)	Какие правила вывода применяются при работе с шаблонами? (с const так же)
•	Если функция принимает T&, то тип Т остается таким же, какого типа аргумент передан в функцию и к нему прибавляется &, если передана ссылка, то && -> &
•	Если функция принимает T&&, то для lvalue выводится [тип]&
•	для rvalue T передается как переданный тип





